---
description: When creating table, or create new form table
globs: 
alwaysApply: false
---
# Table Presentation Style and Form Components

## Page Layout Structure

### Header Pattern
All management pages should follow this consistent header structure:

```tsx
<div className="flex flex-col sm:flex-row sm:items-center justify-between gap-3 sm:gap-0">
  <div>
    <h1 className="text-xl sm:text-2xl font-bold text-gray-900">
      [Entity] Management
    </h1>
    <p className="text-xs sm:text-sm text-gray-600 mt-1">
      [Description of the page functionality]
    </p>
  </div>

  {/* Quick Stats */}
  <div className="flex gap-2 sm:gap-4">
    <div className="bg-white rounded-lg px-3 py-1 sm:px-4 sm:py-2 border border-blue-200">
      <div className="text-lg sm:text-2xl font-bold text-blue-600">
        {totalCount}
      </div>
      <div className="text-xs text-gray-500">Total [Entity]</div>
    </div>
  </div>
</div>
```

### Page Container
Use consistent spacing and responsive padding:
```tsx
<div className="space-y-4 sm:space-y-6 px-2 sm:px-0">
```

## Table Component Structure

### Table Container
```tsx
<div className="bg-white rounded-lg border shadow-sm border-gray-200">
  {/* Table Header Section */}
  <div className="px-4 py-4 sm:px-6 border-gray-200">
    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
      <div>
        <h2 className="text-lg font-semibold text-gray-900">[Entity Name]</h2>
        <p className="text-sm text-gray-600">[Entity description]</p>
      </div>
      <div className="flex items-center gap-2">
        {/* Action buttons */}
      </div>
    </div>
    
    {/* Search Section */}
    <div className="mt-3 sm:mt-4">
      <div className="relative">
        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <SearchIcon className="h-5 w-5 text-gray-400" />
        </div>
        <input
          type="text"
          placeholder="Search [entities]..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        />
      </div>
    </div>
  </div>

  {/* Table */}
  <div className="overflow-x-auto">
    <div className="inline-block min-w-full align-middle">
      <table className="min-w-full divide-y divide-gray-200">
        {/* Table structure */}
      </table>
    </div>
  </div>
</div>
```

### Table Header Style
```tsx
<thead className="bg-gray-50">
  <tr>
    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider sm:px-6">
      Column Name
    </th>
    <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider sm:px-6">
      Actions
    </th>
  </tr>
</thead>
```

### Table Row Style
```tsx
<tbody className="bg-white divide-y divide-gray-200">
  {data.map((item) => (
    <tr key={item.id} className="hover:bg-gray-50 transition-colors">
      <td className="px-4 py-4 whitespace-nowrap text-sm font-medium text-gray-900 sm:px-6">
        {item.name}
      </td>
      <td className="px-4 flex justify-end gap-2 py-4 whitespace-nowrap text-right text-sm font-medium sm:px-6">
        {/* Action buttons */}
      </td>
    </tr>
  ))}
</tbody>
```

### Empty and Error States
```tsx
{error ? (
  <tr>
    <td colSpan={columnCount} className="px-4 py-8 text-center text-red-500 sm:px-6">
      {error}
    </td>
  </tr>
) : filteredItems.length === 0 ? (
  <tr>
    <td colSpan={columnCount} className="px-4 py-8 text-center text-gray-500 sm:px-6">
      {searchTerm ? `No [entities] found matching your search.` : `No [entities] found.`}
    </td>
  </tr>
) : (
  // Render actual data
)}
```

## Action Buttons

### Primary Action Button (Add/Create)
```tsx
<button
  onClick={() => setCreateModalOpen(true)}
  className="inline-flex items-center justify-center px-3 py-2 sm:px-4 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors cursor-pointer"
>
  <PlusIcon className="w-4 h-4 mr-1 sm:mr-2" />
  <span className="whitespace-nowrap">Add [Entity]</span>
</button>
```

### Row Action Buttons
```tsx
<button
  onClick={() => {
    setSelectedItem(item);
    setEditModalOpen(true);
  }}
  className="inline-flex items-center text-blue-600 cursor-pointer hover:text-blue-900 transition-colors"
>
  <PencilIcon className="w-4 h-4 mr-1" />
  Edit
</button>

<button
  onClick={() => {
    setSelectedItem(item);
    setDeleteModalOpen(true);
  }}
  className="inline-flex items-center text-red-600 cursor-pointer hover:text-red-900 transition-colors"
>
  <TrashIcon className="w-4 h-4 mr-1" />
  Delete
</button>
```

## Loading States

### Page Loading Skeleton
```tsx
if (loading) {
  return (
    <div className="space-y-4 sm:space-y-6 px-2 sm:px-0">
      <div className="animate-pulse">
        <div className="h-8 bg-gray-200 rounded w-1/4 mb-2"></div>
        <div className="h-4 bg-gray-200 rounded w-1/2 mb-6"></div>
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4 sm:p-6">
          <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
          <div className="space-y-3">
            {[...Array(6)].map((_, i) => (
              <div key={i} className="h-4 bg-gray-200 rounded"></div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
```

## Form Modal Patterns

### Modal State Management
```tsx
const [createModalOpen, setCreateModalOpen] = useState(false);
const [editModalOpen, setEditModalOpen] = useState(false);
const [deleteModalOpen, setDeleteModalOpen] = useState(false);
const [selectedItem, setSelectedItem] = useState<EntityType | null>(null);
const [actionLoading, setActionLoading] = useState(false);
```

### Form Field Definition
Use the [FormField](mdc:types/FormField.ts) type for consistent field definitions:
```tsx
const formFields: FormField[] = [
  { name: "fieldName", label: "Field Label", type: "text", required: true },
  { name: "selectField", label: "Select Label", type: "select", required: true, options: [...] },
  { name: "numberField", label: "Number Label", type: "number", required: true, defaultValue: "0" },
];
```

### Modal Components Usage
```tsx
{/* Create Modal */}
<FormModal
  isOpen={createModalOpen}
  onClose={() => setCreateModalOpen(false)}
  onSubmit={handleCreate}
  loading={actionLoading}
  title="Add [Entity]"
  fields={formFields}
/>

{/* Edit Modal */}
<FormModal
  isOpen={editModalOpen}
  onClose={() => {
    setEditModalOpen(false);
    setSelectedItem(null);
  }}
  onSubmit={handleEdit}
  loading={actionLoading}
  title="Edit [Entity]"
  fields={formFields}
  initialData={selectedItem || {}}
/>

{/* Delete Modal */}
<AlertModal
  isOpen={deleteModalOpen}
  onClose={() => {
    setDeleteModalOpen(false);
    setSelectedItem(null);
  }}
  onConfirm={handleDelete}
  title="Delete [Entity]"
  description={`Are you sure you want to delete [entity] "${selectedItem?.name}"? This action cannot be undone.`}
  confirmText="Delete"
  cancelText="Cancel"
  loading={actionLoading}
  variant="destructive"
/>
```

## CRUD Handler Patterns

### Create Handler
```tsx
const handleCreate = async (data: Record<string, any>) => {
  const entityData = { /* map form data to entity structure */ };
  setActionLoading(true);
  try {
    const response = await createEntity(entityData);
    if (response.isSuccess) {
      toast.success("[Entity] created successfully");
      setCreateModalOpen(false);
      loadEntities();
    } else {
      toast.error(response.message || "Failed to create [entity]");
    }
  } catch (err) {
    toast.error("Failed to create [entity]");
  } finally {
    setActionLoading(false);
  }
};
```

### Edit Handler
```tsx
const handleEdit = async (data: Record<string, any>) => {
  if (!selectedItem) return;
  setActionLoading(true);
  try {
    const response = await updateEntity(selectedItem.id, data);
    if (response.isSuccess) {
      toast.success("[Entity] updated successfully");
      setEditModalOpen(false);
      setSelectedItem(null);
      loadEntities();
    } else {
      toast.error(response.message || "Failed to update [entity]");
    }
  } catch (err) {
    toast.error("Failed to update [entity]");
  } finally {
    setActionLoading(false);
  }
};
```

### Delete Handler
```tsx
const handleDelete = async () => {
  if (!selectedItem) return;
  setActionLoading(true);
  try {
    const response = await deleteEntity(selectedItem.id);
    if (response.isSuccess) {
      toast.success("[Entity] deleted successfully");
      setDeleteModalOpen(false);
      setSelectedItem(null);
      loadEntities();
    } else {
      toast.error(response.message || "Failed to delete [entity]");
    }
  } catch (err) {
    toast.error("Failed to delete [entity]");
  } finally {
    setActionLoading(false);
  }
};
```

## Pagination Integration

When using pagination, integrate with [usePagination](mdc:helpers/usePagination.ts):
```tsx
const pagination = usePagination({
  data: entities,
  filterFn: filterFunction,
  dependencies: [searchTerm],
});

// Render pagination if needed
{pagination.totalPages > 1 && (
  <Pagination
    currentPage={pagination.currentPage}
    totalPages={pagination.totalPages}
    onPageChange={pagination.goToPage}
    itemsPerPage={pagination.itemsPerPage}
    onItemsPerPageChange={pagination.setItemsPerPage}
    totalItems={entities.length}
    filteredItems={pagination.filteredItems.length}
    startIndex={pagination.startIndex}
    endIndex={pagination.endIndex}
    itemLabel="[entity]"
    itemLabelPlural="[entities]"
  />
)}
```

## Import/Export Functionality

### Import Modal Integration
```tsx
<ImportItemsModal
  isOpen={importModalOpen}
  onClose={() => setImportModalOpen(false)}
  onImport={handleImport}
  loading={actionLoading}
/>
```

### Import Handler
```tsx
const handleImport = async (file: File) => {
  try {
    setActionLoading(true);
    const formData = new FormData();
    formData.append("file", file);
    const response = await importService(formData);
    
    if (response.isSuccess) {
      await loadEntities();
      setImportModalOpen(false);
      toast.success(response.message || "Import successful", {
        duration: 4000,
        style: { fontWeight: '600' },
      });
    } else {
      toast.error(response.message || "Failed to import");
    }
  } catch (error) {
    toast.error("Failed to import");
  } finally {
    setActionLoading(false);
  }
};
```

## Service Integration

### Data Loading Pattern
```tsx
const loadEntities = async () => {
  setLoading(true);
  setError(null);
  try {
    const branch = await getBranchData();
    if (!branch) {
      toast.error("Branch not found");
      return;
    }
    const response = await getEntities(1, 1000, branch.id);
    if (response.isSuccess) {
      setEntities(response.data);
    } else {
      setError(response.message || "Failed to load [entities]");
      toast.error(response.message || "Failed to load [entities]");
    }
  } catch (err) {
    setError("Failed to load [entities]");
    toast.error("Failed to load [entities]");
  } finally {
    setLoading(false);
  }
};
```

## References

- Use [FormModal](mdc:components/CreateModal.tsx) for create operations
- Use [FormModalEdit](mdc:components/EditModal.tsx) for edit operations  
- Use [AlertModal](mdc:components/confirmDelete.tsx) for delete confirmations
- Use [Pagination](mdc:components/Pagination.tsx) for paginated tables
- Use [ImportModal](mdc:components/ImportModal.tsx) for file imports
- Follow [BranchType](mdc:types/BranchType.ts) pattern for type definitions
- Use [usePagination](mdc:helpers/usePagination.ts) for pagination logic
- Follow [getBranchData](mdc:helpers/misc.ts) pattern for branch context
